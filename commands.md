### 1) В чем разница между `ps -ef` и `ps aux`?

**`ps -ef`** и **`ps aux`** имеют схожие функции, но есть и отличия:

- **Формат вывода**: 
  - `ps -ef` подает информацию в формате UNIX, где каждая строка отображает процесс, включая UID (идентификатор пользователя), PID (идентификатор процесса), PPID (идентификатор родительского процесса) и команду.
  - `ps aux` предоставляет более многострочный формат, включая дополнительные параметры, такие как процент использования CPU и памяти.

- **Полномочия**:
  - `ps -ef` создает вывод всех процессов, включая процессы других пользователей, в случае выполнения этой команды с правами суперпользователя.
  - `ps aux` также показывает процессы всех пользователей, но используется для более общей статистики.

### 2) Что лучше использовать для поиска процессов?

Для поиска процессов чаще применяют `ps aux`, так как он предоставляет более детализированную информацию о процессах, что упрощает анализ. Но для специфических сценариев можно использовать `ps -ef`, особенно если привыкли к формату UNIX. 

Для поиска конкретных процессов лучше использовать команду `grep` с `ps`, например:

```bash
ps aux | grep <имя_процесса>
```

Это помогает быстро найти нужный процесс.

### 3) `ps -ef` и `ps aux` ищут процессы в виртуальной файловой системе?

Нет, `ps` не ищет процессы в виртуальной файловой системе (procfs) напрямую, но она использует информацию из `/proc`, которая является виртуальной файловой системой. Файлы в `/proc` содержат информацию о текущих процессах, их состоянии, использовании ресурсов и системе. 

Когда вы выполняете `ps`, он фактически читает данные о процессах из `/proc`, а не из физических файлов на диске.

### 4) Все процессы не хранят свои данные на диске?

Процессы не хранят свои данные на диске в том смысле, что информация о каждом процессе хранится в оперативной памяти. Тем не менее, некоторые данные, связанные с процессами (например, исполняемые файлы и библиотеки), могут находиться на диске, но непосредственно информация о процессе и его состоянии хранится в памяти.

### 5) Все процессы содержат информацию в виртуальной памяти?

Да, процессы существуют в виртуальной памяти. Каждый процесс работает в своем собственном пространстве виртуальной памяти, что позволяет операционной системе изолировать их друг от друга. Это значит, что каждый процесс имеет доступ к своей ячейке памяти, не мешая другим процессам. Виртуальная память позволяет более эффективно использовать память и обеспечивает защиту процессов друг от друга.

### 6) Как посмотреть дерево процессов?

Дерево процессов, в котором видно какой процесс является родительским для других процессов. Такую зависимость можно построить и на основании вывода ps сопоставив значение поля PPID (родительский процесс) интересующего процесса с PID соответствующего процесса. Но в виде дерева все выглядит гораздо нагляднее.

```
pstree -p

systemd(1)─┬─agetty(637)
           ├─agetty(639)
           ├─chronyd(610)───chronyd(614)
           ├─cron(605)
           ├─dbus-daemon(592)
           ├─multipathd(326)─┬─{multipathd}(330)
           │                 ├─{multipathd}(331)
           │                 ├─{multipathd}(332)
           │                 ├─{multipathd}(333)
           │                 ├─{multipathd}(334)
           │                 └─{multipathd}(335)
           ├─networkd-dispat(600)
           ├─rsyslogd(608)─┬─{rsyslogd}(631)
           │               ├─{rsyslogd}(632)
           │               └─{rsyslogd}(633)
           ├─sshd(626)───sshd(709)───bash(784)───pstree(823)
           ├─systemd(713)───(sd-pam)(714)
           ├─systemd-journal(283)
           ├─systemd-logind(613)
           ├─systemd-network(530)
           ├─systemd-resolve(457)
           └─systemd-udevd(329)
```

## 1) Что можем увидеть в /proc?

 В этом каталоге содержатся подкаталоги, соответствующие PID процессов. У каждого процесса есть своя запись в /proc с идентификатором в названии. В каждом из этих подкаталогов можно найти ряд файлов, связанных с данным процессом.

1. `ps aux | grep ssh`:
```
root         626  0.0  0.4  15424  9152 ?        Ss   09:41   0:00 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups
```

2. `cat /proc/626/cmdline`:

cmdline - полная командная строка процесса.

```
sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups
```

3. `ls -l /proc/626/cwd`:

cwd - символьная ссылка на текущий каталог процесса.

```
lrwxrwxrwx 1 root root 0 Mar 11 10:23 /proc/626/cwd -> /
```

4. `ls -l /proc/626/exe`:

exe - символьная ссылка на файл, который должен выполняться.

```
lrwxrwxrwx 1 root root 0 Mar 11 09:41 /proc/626/exe -> /usr/sbin/sshd
```

5. `cat /proc/626/environ`:

environ - переменные среды процесса.

```
hd -D [listener] 0 of 10-100 startups=
```

6. `ls -l /proc/626/fd`:

fd - содержит ссылку на дескрипторы каждого открытого файла.

```
lr-x------ 1 root root 64 Mar 11 10:28 0 -> /dev/null
lrwx------ 1 root root 64 Mar 11 10:28 1 -> 'socket:[17131]'
lrwx------ 1 root root 64 Mar 11 10:28 2 -> 'socket:[17131]'
lrwx------ 1 root root 64 Mar 11 09:41 3 -> 'socket:[17171]'
```