### 1) В чем разница между `ps -ef` и `ps aux`?

**`ps -ef`** и **`ps aux`** имеют схожие функции, но есть и отличия:

- **Формат вывода**: 
  - `ps -ef` подает информацию в формате UNIX, где каждая строка отображает процесс, включая UID (идентификатор пользователя), PID (идентификатор процесса), PPID (идентификатор родительского процесса) и команду.
  - `ps aux` предоставляет более многострочный формат, включая дополнительные параметры, такие как процент использования CPU и памяти.

- **Полномочия**:
  - `ps -ef` создает вывод всех процессов, включая процессы других пользователей, в случае выполнения этой команды с правами суперпользователя.
  - `ps aux` также показывает процессы всех пользователей, но используется для более общей статистики.

### 2) Что лучше использовать для поиска процессов?

Для поиска процессов чаще применяют `ps aux`, так как он предоставляет более детализированную информацию о процессах, что упрощает анализ. Но для специфических сценариев можно использовать `ps -ef`, особенно если привыкли к формату UNIX. 

Для поиска конкретных процессов лучше использовать команду `grep` с `ps`, например:

```bash
ps aux | grep <имя_процесса>
```

Это помогает быстро найти нужный процесс.

### 3) `ps -ef` и `ps aux` ищут процессы в виртуальной файловой системе?

Нет, `ps` не ищет процессы в виртуальной файловой системе (procfs) напрямую, но она использует информацию из `/proc`, которая является виртуальной файловой системой. Файлы в `/proc` содержат информацию о текущих процессах, их состоянии, использовании ресурсов и системе. 

Когда вы выполняете `ps`, он фактически читает данные о процессах из `/proc`, а не из физических файлов на диске.

### 4) Все процессы не хранят свои данные на диске?

Процессы не хранят свои данные на диске в том смысле, что информация о каждом процессе хранится в оперативной памяти. Тем не менее, некоторые данные, связанные с процессами (например, исполняемые файлы и библиотеки), могут находиться на диске, но непосредственно информация о процессе и его состоянии хранится в памяти.

### 5) Все процессы содержат информацию в виртуальной памяти?

Да, процессы существуют в виртуальной памяти. Каждый процесс работает в своем собственном пространстве виртуальной памяти, что позволяет операционной системе изолировать их друг от друга. Это значит, что каждый процесс имеет доступ к своей ячейке памяти, не мешая другим процессам. Виртуальная память позволяет более эффективно использовать память и обеспечивает защиту процессов друг от друга.

### 6) Как посмотреть дерево процессов?

Дерево процессов, в котором видно какой процесс является родительским для других процессов. Такую зависимость можно построить и на основании вывода ps сопоставив значение поля PPID (родительский процесс) интересующего процесса с PID соответствующего процесса. Но в виде дерева все выглядит гораздо нагляднее.

```
pstree -p

systemd(1)─┬─agetty(637)
           ├─agetty(639)
           ├─chronyd(610)───chronyd(614)
           ├─cron(605)
           ├─dbus-daemon(592)
           ├─multipathd(326)─┬─{multipathd}(330)
           │                 ├─{multipathd}(331)
           │                 ├─{multipathd}(332)
           │                 ├─{multipathd}(333)
           │                 ├─{multipathd}(334)
           │                 └─{multipathd}(335)
           ├─networkd-dispat(600)
           ├─rsyslogd(608)─┬─{rsyslogd}(631)
           │               ├─{rsyslogd}(632)
           │               └─{rsyslogd}(633)
           ├─sshd(626)───sshd(709)───bash(784)───pstree(823)
           ├─systemd(713)───(sd-pam)(714)
           ├─systemd-journal(283)
           ├─systemd-logind(613)
           ├─systemd-network(530)
           ├─systemd-resolve(457)
           └─systemd-udevd(329)
```

### 7) Что такое load average? Это отношение чего к чему?

**Load average** (нагрузка на систему) — это метрика, показывающая количество процессов, ожидающих выполнения на процессоре, за определенные интервалы времени (возможные временные интервалы: 1, 5 и 15 минут). Это значение может быть интерпретировано как среднее количество занятых или ожидающих выполнения процессов за указанные периоды.

Load average показывает, насколько загружена система:

- **Никогда не будет равно количеству ядер**: Например, load average в 1.0 на системе с 1 ядром означает, что есть 1 процесс, который активно работает или ожидает своей очереди. На системе с 8 ядрами это значение считалось бы нормальным, так как система способна обрабатывать до 8 одновременно выполняемых процессов.

### 8) Сервер с 8 ядрами должен работать в норме при каких LA? А при каких LA ему будет плохо?

Для сервера с 8 ядрами можно считать такие значения load average нормальными:

- **Нормальные значения**: 
  - 1.0 или ниже для системы с 1 ядром.
  - 8.0 или ниже для системы с 8 ядрами.
  Это значит, что в любой момент времени количество работающих и ожидающих выполнения процессов не превышает количество доступных ядер.

- **Плохие значения**:
  - Значения выше 8.0 будут говорить о том, что система перегружена (все ядра заняты, и есть процессы, ожидающие выполнения).
  - Если Load Average значительно превышает количество ядер (например, выше 16.0 на 8-ядровом сервере), это может указывать на серьезные проблемы с производительностью, что может потребовать диагностики.


## 1) Что можем увидеть в /proc?

 В этом каталоге содержатся подкаталоги, соответствующие PID процессов. У каждого процесса есть своя запись в /proc с идентификатором в названии. В каждом из этих подкаталогов можно найти ряд файлов, связанных с данным процессом.

1. `ps aux | grep ssh`:
```
root         626  0.0  0.4  15424  9152 ?        Ss   09:41   0:00 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups
```

2. `cat /proc/626/cmdline`:

cmdline - полная командная строка процесса.

```
sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups
```

3. `ls -l /proc/626/cwd`:

cwd - символьная ссылка на текущий каталог процесса.

```
lrwxrwxrwx 1 root root 0 Mar 11 10:23 /proc/626/cwd -> /
```

4. `ls -l /proc/626/exe`:

exe - символьная ссылка на файл, который должен выполняться.

```
lrwxrwxrwx 1 root root 0 Mar 11 09:41 /proc/626/exe -> /usr/sbin/sshd
```

5. `cat /proc/626/environ`:

environ - переменные среды процесса.

```
hd -D [listener] 0 of 10-100 startups=
```

6. `ls -l /proc/PID/fd`:

fd - содержит ссылку на дескрипторы каждого открытого файла. `ls -l /proc/626/fd` - показывает открытые дескрипторы для процесса с PID 626.

- Дескриптор **0** (stdin) указывает на `/dev/null`, что означает, что процесс не принимает ввода.
- Дескрипторы **1** и **2** (stdout и stderr, соответственно) указывают на сокеты, что говорит о том, что процесс отправляет свои данные через сетевое соединение, использующее сокеты.

```
lr-x------ 1 root root 64 Mar 11 10:28 0 -> /dev/null
lrwx------ 1 root root 64 Mar 11 10:28 1 -> 'socket:[17131]'
lrwx------ 1 root root 64 Mar 11 10:28 2 -> 'socket:[17131]'
lrwx------ 1 root root 64 Mar 11 09:41 3 -> 'socket:[17171]'
```
