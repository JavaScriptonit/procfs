## Дескрипторы

### 1) Что такое дескрипторы и зачем они нужны?

**Файловые дескрипторы** — это неотрицательные целые числа, которые операционная система использует для управления открытыми файлами и другими ресурсами, такими как сокеты, каналы и устройства ввода-вывода. Они служат в качестве индикаторов для идентификации открытых файлов в процессе.

Каждому процессу в Unix-подобных системах назначаются три стандартных файловых дескриптора при запуске (автоматически создаются):
- **0**: стандартный ввод (stdin)
- **1**: стандартный вывод (stdout)
- **2**: стандартный вывод ошибок (stderr)

Для каждого открытого файла или ресурса в системе создается дескриптор, который позволяет процессам взаимодействовать с этими ресурсами.

### 2) Что нужно знать о дескрипторах DevOps инженеру?

1. **Лимиты на дескрипторы**: Необходимо понимать, что операционные системы ограничивают количество открытых файловых дескрипторов для каждого процесса (обычно 1024 или 4096, в зависимости от системы). Это важно для обеспечения стабильности приложений.

2. **Управление дескрипторами**: Знать как открывать и закрывать дескрипторы, исполняя команды типа `lsof` для просмотра открытых файлов и ресурсов, которые использует процесс.

3. **Диагностика**: Понимание файловых дескрипторов может быть полезным для диагностики проблем с производительностью, таких как утечки дескрипторов (когда приложение не закрывает открытые дескрипторы), что может привести к исчерпанию доступных дескрипторов.

4. **Чтение и запись**: Знать, как работать с файловыми дескрипторами в контексте сетей и потоков данных, например, использование `socket` дескрипторов при коммуникации между процессами.

### 3) Пример вывода для `/proc/626` (ssh демона, sshd процесса):

**Вывод процесса** — это данные, которые процесс отправляет на стандартный вывод, который может отображаться на экране терминала или перенаправляться в файл. Для `sshd` стандартный вывод (дескриптор 1) может использоваться для отправки обратно информации пользователю.

**Пример**: После выполнения команды через SSH, например, `ls`, `sshd` отправляет результат выполнения этой команды обратно клиенту. Этот вывод попадает в стандартный вывод и отображается в терминале вашего SSH-клиента.

### 4) Пример ввода для /proc/626 (ssh демона, sshd процесса):

**Ввод процесса** — это данные, которые процесс получает из внешнего источника, например, с клавиатуры, из файла или от другого процесса. В контексте SSH-демона (sshd), стандартный ввод может получать команды от SSH-клиента.

**Пример**: Если вы подключаетесь к вашему серверу через SSH, ваши команды, такие как `ls` или `cd`, отправляются на сервер через стандартный ввод `sshd` процесса (дескриптор 0). Это происходит следующим образом:
- Вы вводите команду в терминале.
- Эта команда отправляется через SSH-соединение, и `sshd`, который слушает на порту, принимает ее через стандартный ввод.

### 5) Как открывать и закрывать дескрипторы?

**Открытие дескрипторов**:
- Дескрипторы открываются автоматически операционной системой при открытии файла, сокета или другого ресурса процессом. Разработчик или системный администратор может программно управлять этим процессом, используя системные вызовы в таких языках программирования, как C.
- Например, для открытия файла в C используется функция `open()`, которая возвращает файловый дескриптор.

**Закрытие дескрипторов**:
- Дескриптор закрывается с помощью системного вызова `close()` в программном коде, что освобождает ресурс и позволяет другим процессам его использовать.

**Пример с `lsof` для `sshd`**:
```bash
lsof -p 626
# Здесь 626 - это PID sshd. Это покажет все открытые файлы и сокеты для этого процесса.
```

### 2) Как посмотреть ограничения ОС на количество открытых файловых дескрипторов для каждого процесса?

Ограничения на количество открытых файловых дескрипторов можно посмотреть с помощью команды `ulimit`. Используйте следующие команды:

```bash
# Ограничение на количество открытых файлов для текущего пользователя
ulimit -n

# Пример для sshd
cat /proc/sys/fs/file-max
```

```
# Для просмотра лимитов на уровне конкретного процесса можно также использовать:
cat /proc/<PID>/limits
# Например, для sshd:
cat /proc/626/limits
```

В выводе будет строка, показывающая максимальное количество открытых дескрипторов.
  
### 3) Как использовать socket дескрипторов при коммуникации между процессами (как работать с файловыми дескрипторами)?

**Сокеты** используются для межпроцессного взаимодействия. При использовании сокетов ваше приложение может наладить связь с другим приложением как локально, так и по сети.

Когда вы видите ссылки на сокеты в `/proc/626/fd`, это означает, что `sshd` использует эти сокеты для связи с другими процессами, включая клиентов SSH, и, возможно, другие сервисы, зависящие от `sshd`.

#### Пример работы с сокетами в контексте SSH:

- При подключении к серверу через SSH создается несколько сокетов, которые управляются процессом `sshd`. 
- `sshd` прослушивает входящие соединения на определенном порту (обычно 22) и использует сокеты для обработки новых детей для каждого входящего соединения.

### Что такое сокеты `17131` и `17171`?

- Сокет `17131` указывает на связь между клиентом и сервером (`sshd`). Это обеспечивает связь между вашим SSH-клиентом и процессом `sshd`.
- Сокет `17171` может использоваться `sshd` для внутренней обработки. Он может представлять внутреннюю связь между дочерними процессами `sshd` или взаимодействие с другими компонентами.

### Пример работы с сокетами в C:

Для примера работы с сокетами на базе C, общий цикл для создания сокета может выглядеть следующим образом:

```c
#include <sys/socket.h>
#include <netinet/in.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    int sock;
    struct sockaddr_in server_addr;

    // Создание сокета
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) {
        perror("Socket creation error");
        exit(EXIT_FAILURE);
    }

    // Настройка структуры адреса сервера
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(8080);

    // Привязка сокета к порту
    if (bind(sock, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        perror("Bind failed");
        close(sock);
        exit(EXIT_FAILURE);
    }

    // Прослушивание порта
    listen(sock, 5);
    printf("Listening for connections...\n");

    // В дальнейшем здесь может быть код для accept и отправки/приема данных.

    close(sock); // Закрытие сокета
    return 0;
}
```

Этот код создает сокет, связывает его с адресом и портом, а затем прослушивает входящие соединения. 
